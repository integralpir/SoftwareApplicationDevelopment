# Занятие №2 14.10.2024
## Объектно - ориентированное программирование

> ООП - это Очень Огромные Пространства, а не вот это вот все... *Иван Носов*

### Что такое ООП?

Умное определение вы можете загуглить и сами, 
а по сути ООП - это подход, который позволяет ***отобразить в программе сущности из реального мира***, 
связать предметную область и программную реализацию.

Самые базовые термины которые нужно знать для работы с ООП:
- ***Класс*** - это программное описание какой-либо сущности, ее свойств и методов, которые эта сущность может выполнять. 
Иными словами класс - это чертеж.
```java
// объявление класса с помощью ключевого слова class
class Dog {
    // объявление поля name 
    // поля отражают свойства будущего объекта
    String name;
    LocalDate birthDate;

    // объявление метода sayWoof
    // методы отражают "способности" свойственные всем объектам класса
    void sayWoof() {
        System.out.println("Woof-woof");
    }
}
```
- ***Объект*** - это уникальный (или нет) экземпляр класса, с собственным значением свойств класса.
- ***Конструктор*** - мы можем прописать метод, который будет автоматически выполняться, во время создания объекта. 
Обычно в конструкторе просто присваивают значения свойствам, но никто не запрещает прописать в нем какую-нибудь логику.
В java, если конструктор не указан, то у класса все равно есть конструктор - конструктор без аргументов.

```java
import java.time.LocalDateTime;

// объявление класса с помощью ключевого слова class
class Dog {
    // объявление поля name 
    // поля отражают свойства будущего объекта
    String name;
    LocalDate birthDate;

    Dog(String name) {
        //Присваиваем значения свойствам
        this.name = name;
        //Выполняем логику
        this.birthDate = LocalDate.now();
        System.out.println("Dog was born.");
    }

    // объявление метода sayWoof
    // методы отражают "способности" свойственные всем объектам класса
    void sayWoof() {
        System.out.println("Dog: " + this.name + " say: \"Woof-woof\".");
    }
} 
```

```java
import examples.Dog;

// клиентский код
public class Main {
    public static void main(String[] args) {
        // создаем новый экземпляр (объект) класса examples.Dog
        // по кличке Rex (свойство name объекта равно Rex)
        Dog rex = new Dog("Rex");

        // вызываем метод
        // пес по кличке Rex лает
        rex.sayWoof();
    }
}
```

- ```this``` - ключевое слово, использующееся внутри класса, для обозначения того, что идет обращение к переменной / методу класса.
- ```new``` - ключевое слово, необходимое для создания нового объекта. После слова new вызывается конструктор объекта, в конструктор передаются параметры.

Все методы зависят от внутреннего состояния класса, грубо говоря, чтобы иметь возможность использовать метод, 
необходимо создать экземпляр класса (объект). Для того чтобы сделать метод или переменную независимой от внутреннего состояния объекта,
нужно пометить переменную / метод ключевым словом ```static``` 
(например метод ```main```, если он не будет объявлен ```static```, то для его запуска понадобится экземпляр класса examples.Main,
но мы не можем его создать, т.к. выполнение всей программы начинается с метода ```main```, для этого он отвязан от состояния объекта ключевым словом ```static```). 

### Основные принципы ООП

Кто-то говорит, что их 3, кто-то, что 4...

Я отношусь (относился) ко второй группе. Итак, основные принципы ООП:
1. **наследование**;
2. **инкапсуляция**;
3. **полиморфизм**;
4. **абстракция**.
___
#### Наследование

*Наследование* позволяет переиспользовать и расширять методы и свойства одних классов другим. 

Разберем на примере, как и у собак у кошек есть такие свойства как кличка (```name```) и день рождения (```birthDate```), 
к тому же, кошки, как и собаки, могут перемещаться в пространстве. 
Таким образом используя наследование, мы можем агрегировать общие свойства и методы в классе родителе, 
а реализацию индивидуальных методов оставить классам оставить классам наследникам.

В java наследование объявляется с помощью ключевого слова ```extends```. 
Возможно вы слышали, читали или только прочитаете про множественное наследование, 
дак вот, в java наследоваться можно только от одного класса.

```java
import java.time.LocalDate;

// Класс родитель
class Animal {
    String name;
    LocalDate birthDate;

    Animal(String name) {
        this.name = name;
        birthDate = LocalDate.now();
    }

    void move(int x, int y) {
        System.out.println(this.name + " : move from " + x + " to " + y + ".");
    }
}
```

```java
class Dog extends Animal {
    Dog(String name) {
        super(name);
    }

    void sayWoof() {
        System.out.println("Dog: " + this.name + " say: \"Woof-woof\".");
    }
}
```

```java
class Cat extends Animal {
    Cat(String name) {
        super(name);
    }

    void sayMeow() {
        System.out.println("Cat: " + this.name + " say: \"Meow-meow\".");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // создаем объекты, пса Rex'a и кота Scheldon'a
        Dog rex = new Dog("Rex");
        Cat sheldon = new Cat("Sheldon");

        // вызываем методы уникальные методы классов
        rex.sayWoof();
        sheldon.sayMeow();

        // вызываем общие методы агрегированные в классе Animal
        rex.move(1, 2);
        sheldon.move(1, 2);

        // вызываем общие поля описанные в классе Animal
        System.out.println(rex.name);
        System.out.println(rex.birthDate);

        System.out.println(sheldon.name);
        System.out.println(sheldon.birthDate);
    }
}
```
___
#### Инкапсуляция

Инкапсуляция - это контроль доступа к полям и методам объекта.

Частным случаем инкапсуляции является сокрытие данных которое реализуется через модификаторы доступа. 
Для начала достаточно знать его, а уже в дальнейшем вы разберетесь в различных валидациях и пр. пр. пр.

В java существует 4 модификатора доступа:
1. ```public``` - видимость у всех классов.
2. ```private``` - видимость у класса.
3. ```protected``` - видимость у классов пакета и классов наследников.
4. ```default``` - видимость у классов пакета. Данный модификатор присваивается по умолчанию, если не был указан другой.

```java
import java.time.LocalDate;

// класс доступен всему коду
public class Animal {
    private String name;
    private final LocalDate birthDate;

    // конструктор открыт всему коду, для свободной возможности создания объектов
    public Animal(String name) {
        this.name = name;
        birthDate = LocalDate.now();
    }

    // свободный доступ к методу
    public void move(int x, int y) {
        System.out.println(this.name + " : move from " + x + " to " + y + ".");
    }

    // аксессоры
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public LocalDate getBirthDate() {
        return birthDate;
    }
}
```
___
#### Полиморфизм

Полиморфизм позволяет иметь множество реализаций одного интерфейса.

В java существует такая программная сущность как интерфейс, в большинстве случаев, ее реализация не содержит полей или реализованных методов. 
Грубо говоря, интерфейс это список методов которые класс обязан реализовывать.

Разберем на примере...

Если рассматривать наших любимых кошек и собак, то мы можем выделить еще одну общую черту, они могут в той или иной форме подавать голос,
но реализация у них разная. Для того чтобы как-то выделить их в группу созданий "подающих голос" мы можем указать, что наши классы реализуют общий интерфейс, 
и прописать метод описанный в интерфейсе.

```java
// как правило интерфейс содержит только сигнатуру метода
public interface Speaking {
    void speakUp();
}
```

```java
class Cat extends Animal implements Speaking {
    Cat(String name) {
        super(name);
    }

    @Override
    public void speakUp() {
        System.out.println("Cat: " + this.getName() + " say: \"Meow-meow\".");
    }
}
```

```java
class Dog extends Animal implements Speaking {
    Dog(String name) {
        super(name);
    }

    @Override
    public void speakUp() {
        System.out.println("Dog: " + this.getName() + " say: \"Woof-woof\".");
    }
}
```

В отличие от наследования, реализация (```implements```) может быть множественной, мы можем указать, что собака водоплавающая, а кошка нет,
но при этом они останутся "говорящими".

>```@Override``` - аннотация, обозначающая переопределение метода, не путать с перегрузкой.

Таким образом, имея один интерфейс \ контракт, мы можем использовать множество его реализаций в ООП.

___
#### Абстракция

Резюмируя все сказанное мной на лекции в этом файле, я понял, что кажется был не прав насчет абстракции.
Абстракция это скорее про умение выделить общее из частного, а не про какую-то программную сущность. 

___
### Вывод

Вышеизложенное описание ООП довольно поверхностное и требует определенных уточнений. 
Пока что здесь нет информации про функциональные интерфейсы, про абстрактные классы, очень мало сказано про ```static``` элементы, 
про композицию и агрегирование и многого другого. Тем не менее этого хватит, чтобы вы поняли, что такое ООП и как его использовать.

> *Безусловно я буду дополнять информацию, но не надейтесь на меня, если вам нужна информация старайтесь искать ее сами,
> пару ссылок я приложил внизу. Быстрый поиск информации - главное оружие отнюдь не студента, это главное оружие работника IT. C:* 

___
## Задание

Вы все выбрали тематику проектов и открытые API в соответствии с вашей тематикой. 
Ваше задание будет заключаться в переносе сущностей которые предоставляет API на классы выбранного вами языка программирования.

Также необходимо продумать манипуляции над объектом, чтобы работа вашей системы не напоминала перекладывание чего-бы то ни было с места на место,
над объектом должна проводиться манипуляция.

Пример решенного задания будет в пакете ```model```.
___
## Полезные ссылки

- Добротная статья по теме - https://habr.com/ru/articles/463125/
- Подробно об отличиях интерфейса и абстрактного класса - https://habr.com/ru/companies/otus/articles/707762/
- О модификаторах доступа https://javarush.com/groups/posts/1988-modifikatorih-dostupa-private-protected-default-public